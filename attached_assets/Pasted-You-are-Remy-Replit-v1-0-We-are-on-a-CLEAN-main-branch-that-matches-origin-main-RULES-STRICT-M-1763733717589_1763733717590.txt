You are Remy Replit (v1.0). We are on a CLEAN main branch that matches origin/main.

RULES (STRICT MODE)
- Do NOT run any git commands (no add/commit/push/checkout/rebase/etc).
- Do NOT touch branches.
- Before editing, print a short plan with the files you’ll touch.
- After editing, run `cd client && npm run build` once and report the result and logs.
- If anything is unclear, ask me instead of guessing.

GOAL
Reapply the 7-file update plan so the app builds cleanly for Railway:

FILES TO CREATE / REPLACE

1) REPLACE `client/src/lib/queryClient.ts` with:

```ts
import { QueryClient } from "@tanstack/react-query";

export const queryClient = new QueryClient();
CREATE (or overwrite) client/src/pages/not-found.tsx with:

tsx
Copy code
import { Link } from "wouter";

export default function NotFound() {
  return (
    <main className="min-h-screen flex flex-col items-center justify-center gap-4 p-6 text-center">
      <h1 className="text-3xl font-bold">404 – Page not found</h1>
      <p>
        The page you requested doesn&apos;t exist. It may have been moved or deleted.
      </p>
      <Link href="/" className="underline">
        Go back to the homepage
      </Link>
    </main>
  );
}
CREATE (or overwrite) client/src/lib/utils.ts with:

ts
Copy code
// Simple className combiner used by components.
// Accepts strings or falsy values and joins the truthy ones with spaces.
export function cn(
  ...classes: Array<string | false | null | undefined>
): string {
  return classes.filter(Boolean).join(" ");
}
CREATE (or overwrite) client/src/hooks/use-toast.ts with:

ts
Copy code
type ToastOptions = {
  title?: string;
  description?: string;
  variant?: "default" | "destructive";
};

/**
 * Minimal toast hook used to satisfy imports.
 * In production you can replace this with a full UI toast system.
 */
export function useToast() {
  function toast(options: ToastOptions) {
    if (import.meta.env.DEV) {
      // eslint-disable-next-line no-console
      console.log("[toast]", options);
    }
  }

  return { toast };
}
CREATE (or overwrite) shared/wordpress-metadata.ts with:

ts
Copy code
export type TemplateMode = "template" | "agent" | "media";

export type TemplateMetadata = {
  label: string;
  description: string;
  category: string;
};

export const TEMPLATE_METADATA: Record<TemplateMode, TemplateMetadata> = {
  template: {
    label: "Prompt Template",
    description: "Single structured prompt template for a task or workflow.",
    category: "Prompt Templates",
  },
  agent: {
    label: "Prompt Agent",
    description: "Multi-step or persona-style agent prompt with a role, context, and workflow.",
    category: "Agents",
  },
  media: {
    label: "Media Blueprint",
    description: "Prompt blueprint tailored for media generation (video, image, audio, etc.).",
    category: "Media",
  },
};
REPLACE server/routes.ts ENTIRELY with:

ts
Copy code
import { type Express } from "express";
import { createServer, type Server } from "http";
import { generatePrompt } from "./services/promptGenerator";
import { storage } from "./storage";
import { assertModelAvailable } from "./guards/modelGate.js";
import { getModelRegistry } from "./services/modelRegistry.js";
// Import publishing modules
import {
  ensureTerms,
  generateTitle,
  uniqueSlug,
  buildPayload,
  logPreflight,
  PublishingStateMachine,
  PublishingState,
  type PostPayload
} from "./publishing/index.js";
// Import WordPress publisher
import { savePromptToWordPress, validateWordPressPublish } from "./services/wordpressPublisher.js";
import { TEMPLATE_METADATA } from "../shared/wordpress-metadata.js";
import { z } from "zod";
// Import releases route
import releasesRouter from "./routes/releases.js";

// Top-level flags
const USE_MOCKS = process.env.USE_MOCKS === "true";
const GENERATE_TIMEOUT_MS = Number(process.env.GENERATE_TIMEOUT_MS ?? 30000);

function computeValidation(text: string): { clarity: number; structureOk: boolean; lengthChars: number } {
  const t = text || "";
  const len = t.length;
  const sentences = t.split(/[.!?]\s+/).filter(Boolean);
  const words = t.trim().split(/\s+/).filter(Boolean);
  const avgSent = sentences.length ? (words.length / sentences.length) : words.length;
  const hasHeadings = /^(#{1,6}\s|\s*[-*]\s|\d+\.\s)/m.test(t);
  const hasSections = /(##\s*Role|##\s*Context|##\s*Instructions|##\s*Output|###\s*Steps|###\s*Path)/i.test(t);
  let clarity = 40;
  if (len >= 200 && len <= 2000) clarity += 15;
  if (avgSent >= 8 && avgSent <= 24) clarity += 25;
  if (hasHeadings) clarity += 10;
  if (hasSections) clarity += 10;
  if (clarity > 100) clarity = 100;
  if (clarity < 0) clarity = 0;
  return { clarity, structureOk: (hasHeadings || hasSections), lengthChars: len };
}

function withTimeout<T>(p: Promise<T>, ms = GENERATE_TIMEOUT_MS): Promise<T> {
  return new Promise<T>((resolve, reject) => {
    const t = setTimeout(() => reject(new Error("TIMEOUT")), ms);
    p.then(v => { clearTimeout(t); resolve(v); }).catch(e => { clearTimeout(t); reject(e); });
  });
}

// Helper function to calculate trust score
function calculateTrustScore(trustSettings: any): number {
  let score = 50; // Base score
  if (trustSettings?.safetyMode) score += 10;
  if (trustSettings?.ethicalGuardrails) score += 10;
  if (trustSettings?.consentSafeMode) score += 10;
  if (trustSettings?.clarityLevel >= 3) score += 10;
  if (trustSettings?.rubric === "strict") score += 10;
  return Math.min(score, 100);
}

function simpleClarityScore(text: string): number {
  const t = text || "";
  const headingCount = (t.match(/^##s/mg) || []).length;
  const bulletLines  = (t.match(/^s*(?:[-*]|d+.)s/mg) || []).length;
  const len = t.length;
  let score = 30;
  score += Math.min(headingCount,5) * 10;  // up to +50
  score += Math.min(bulletLines,8) * 3;    // up to +24
  if (len >= 400 && len <= 5000) score += 20; // broader window than 2000
  else if (len >= 200) score += 10;
  if (score > 100) score = 100;
  if (score < 0) score = 0;
  return Math.round(score);
}

export async function registerRoutes(app: Express): Promise<Server> {
  // Generate endpoint
  app.post("/api/generate", async (req, res) => {
    try {
      const { mode, formData, trustSettings } = req.body ?? {};

      console.log(`[API /api/generate] USE_MOCKS=${USE_MOCKS}, mode=${mode}`);

      if (USE_MOCKS) {
        console.log('[API /api/generate] Using routes.ts mock path (USE_MOCKS=true)');
        // Zero-cost local generation
        const promptText = `[MOCK ${mode?.toUpperCase() ?? "TEMPLATE"}]\n` +
          `Title: ${formData?.title ?? "Untitled"}\n` +
          `Goal: ${formData?.goal ?? "N/A"}\n` +
          `Task: ${formData?.task ?? "N/A"}\n` +
          `Context: ${formData?.context ?? "N/A"}\n` +
          `Constraints: ${JSON.stringify(trustSettings ?? {})}`;

        const trustScore = simpleClarityScore(promptText);
        const id = await storage.createPrompt({
          mode: mode || "template",
          title: formData?.title || `${mode} prompt`,
          promptText,
          formData: formData || {},
          trustSettings: trustSettings || {},
          trustScore
        });

        return res.status(200).json({
          ok: true,
          promptText,
          trustScore,
          trustBadgeEligible: trustScore >= 80,
          promptId: id.id,
        });
      }

      console.log('[API /api/generate] Taking real generation path, calling promptGenerator.ts');
      // Real generation path (decoupled from model availability)
      const generationPromise = generatePrompt(mode, formData, trustSettings);
      const result = await withTimeout(generationPromise);

      if (!result?.promptText?.trim()) throw new Error("EMPTY_PROMPT");

      const trustScore = simpleClarityScore(result.promptText);
      const id = await storage.createPrompt({
        mode,
        title: formData?.title || `${mode} prompt`,
        promptText: result.promptText,
        formData,
        trustSettings,
        trustScore
      });

      return res.status(200).json({
        ok: true,
        promptText: result.promptText,
        trustScore,
        trustBadgeEligible: trustScore >= 80,
        promptId: id.id,
        resolvedModel: result.resolvedModel,
        usedMock: result.usedMock,
      });
    } catch (e: any) {
      const msg = e?.message === "TIMEOUT" ? "Generation timed out." : (e?.message || "Generate failed");
      return res.status(400).json({ ok: false, error: msg });
    }
  });

  // Test endpoint - Run test with model availability check
  app.post("/api/test", async (req, res) => {
    try {
      const { modelId, prompt, mode } = req.body;
      const registry = await getModelRegistry();

      // Check model availability
      assertModelAvailable(modelId, registry);

      // Run test logic here
      res.status(200).json({
        ok: true,
        message: "Test completed successfully",
        mode,
        promptLength: prompt?.length || 0
      });
    } catch (e: any) {
      res.status(e.status ?? 500).json({
        ok: false,
        code: e.code,
        message: e.message
      });
    }
  });


  // Model Registry endpoint
  app.get("/api/models", async (_req, res) => {
    try {
      const registry = await getModelRegistry();
      res.json({
        ok: true,
        models: registry
      });
    } catch (error: any) {
      console.error("Error fetching model registry:", error);
      res.status(500).json({
        ok: false,
        error: "INTERNAL_ERROR",
        message: "Failed to fetch model registry"
      });
    }
  });

  // Publishing preflight endpoint
  app.post("/api/preflight", async (req, res) => {
    try {
      const { title, content, categories = [], tags = [], mode, metadata = {} } = req.body;

      // Initialize state machine
      const stateMachine = new PublishingStateMachine();
      stateMachine.transition(PublishingState.PREFLIGHT);

      // Step 1: Ensure terms exist
      const termsResult = await ensureTerms({ categories, tags });

      // Step 2: Generate title if not provided
      const finalTitle = title || generateTitle({
        mode,
        goal: metadata.goal,
        category: categories[0],
        agentName: metadata.agentName,
        platform: metadata.platform,
        mediaStyle: metadata.mediaStyle
      });

      // Step 3: Generate unique slug
      const baseSlug = finalTitle.toLowerCase()
        .replace(/[^a-z0-9\s-]/g, '')
        .replace(/\s+/g, '-')
        .replace(/-+/g, '-')
        .trim();

      // Mock slug checker for now
      const slugChecker = async (slug: string) => {
        // In production, would check database for existing slugs
        return false; // For now, assume no duplicates
      };

      const finalSlug = await uniqueSlug(baseSlug, slugChecker);

      // Step 4: Validate payload requirements
      const validationErrors: string[] = [];
      const validationWarnings: string[] = [];

      if (categories.length === 0) {
        validationErrors.push("At least one category is required");
      }

      if (tags.length < 3) {
        validationErrors.push("At least 3 tags are required");
      }

      if (!content || content.length < 10) {
        validationWarnings.push("Content seems too short");
      }

      const isValid = validationErrors.length === 0;

      // Build payload only if we have the minimum requirements
      let payload: PostPayload | null = null;
      if (content && categories.length > 0 && tags.length >= 3) {
        payload = buildPayload({
          title: finalTitle,
          slug: finalSlug,
          content: content || '',
          categories,
          tags,
          meta: metadata
        });
      }

      // Log preflight completion
      await logPreflight('preflight_complete', {
        title: finalTitle,
        slug: finalSlug,
        termsCreated: termsResult.created.length,
        termsExisting: termsResult.existing.length,
        valid: isValid
      });

      // Transition state based on validation
      if (isValid) {
        stateMachine.transition(PublishingState.READY_TO_PUBLISH);
      }

      res.json({
        success: true,
        title: finalTitle,
        slug: finalSlug,
        termsResult,
        payload,
        state: stateMachine.getState(),
        validation: {
          isValid,
          errors: validationErrors,
          warnings: validationWarnings
        }
      });
    } catch (error: any) {
      console.error("Preflight error:", error);
      res.status(500).json({
        success: false,
        error: "Preflight failed",
        details: error.message
      });
    }
  });

  // Create draft endpoint
  app.post("/api/draft", async (req, res) => {
    try {
      const { payload } = req.body as { payload: PostPayload };

      if (!payload) {
        return res.status(400).json({
          success: false,
          error: "Payload is required"
        });
      }

      // Store draft in memory
      const id = await storage.createPrompt({
        mode: 'template',
        title: payload.title,
        promptText: payload.content,
        formData: payload.meta || {},
        trustSettings: {},
        trustScore: 0
      });

      await logPreflight('draft_created', {
        id,
        title: payload.title,
        slug: payload.slug
      });

      res.json({
        success: true,
        draftId: id,
        message: "Draft created successfully"
      });
    } catch (error: any) {
      console.error("Draft creation error:", error);
      res.status(500).json({
        success: false,
        error: "Failed to create draft",
        details: error.message
      });
    }
  });

  // Publish endpoint
  app.post("/api/publish", async (req, res) => {
    try {
      const { payload, validation } = req.body;

      if (!payload) {
        return res.status(400).json({
          success: false,
          error: "Payload is required"
        });
      }

      // Check validation
      if (!validation?.isValid) {
        return res.status(400).json({
          success: false,
          error: "Validation failed",
          details: validation?.errors || ["Cannot publish with validation errors"]
        });
      }

      // Store published prompt
      const id = await storage.createPrompt({
        mode: payload.meta?.mode || 'template',
        title: payload.title,
        promptText: payload.content,
        formData: payload.meta || {},
        trustSettings: {},
        trustScore: payload.meta?.trustScore || 0
      });

      await logPreflight('prompt_published', {
        id,
        title: payload.title,
        slug: payload.slug
      });

      res.json({
        success: true,
        publishedId: id,
        message: "Prompt published successfully",
        url: `/prompts/${id}`
      });
    } catch (error: any) {
      console.error("Publishing error:", error);
      res.status(500).json({
        success: false,
        error: "Failed to publish",
        details: error.message
      });
    }
  });

  // Get all prompts
  app.get("/api/prompts", async (_req, res) => {
    try {
      const prompts = await storage.getAllPrompts();
      res.json({ prompts });
    } catch (error: any) {
      console.error("Error fetching prompts:", error);
      res.status(500).json({
        error: "Failed to fetch prompts",
        details: error.message
      });
    }
  });

  // Get single prompt
  app.get("/api/prompts/:id", async (req, res) => {
    try {
      const prompt = await storage.getPrompt(req.params.id);
      if (!prompt) {
        return res.status(404).json({ error: "Prompt not found" });
      }
      res.json(prompt);
    } catch (error: any) {
      console.error("Error fetching prompt:", error);
      res.status(500).json({
        error: "Failed to fetch prompts",
        details: error.message
      });
    }
  });

  // WordPress publishing endpoint
  app.post("/api/wordpress/publish", async (req, res) => {
    try {
      // Zod schema for request validation
      const wpPublishSchema = z.object({
        title: z.string().min(1, "Title is required").max(200, "Title must be less than 200 characters"),
        content: z.string().min(1, "Content is required").max(100000, "Content is too large"),
        templateMode: z.enum(Object.keys(TEMPLATE_METADATA) as [string, ...string[]], {
          errorMap: () => ({ message: "Invalid template mode" })
        })
      });

      // Parse and validate request body
      const parseResult = wpPublishSchema.safeParse(req.body);

      if (!parseResult.success) {
        const errors = parseResult.error.errors.map(e => e.message);
        console.warn('[API /api/wordpress/publish] Validation failed:', errors);
        return res.status(400).json({
          success: false,
          error: 'Invalid request data',
          details: errors
        });
      }

      const { title, content, templateMode } = parseResult.data;

      // Additional validation
      const validation = validateWordPressPublish(title, content);
      if (!validation.valid) {
        return res.status(400).json({
          success: false,
          error: 'Validation failed',
          details: validation.errors
        });
      }

      // Attempt to save to WordPress
      const result = await savePromptToWordPress(title, content, templateMode);

      if (result.success) {
        console.log('[API /api/wordpress/publish] Success:', result);
        res.json(result);
      } else {
        console.error('[API /api/wordpress/publish] Failed:', result.error);

        // Return appropriate status code based on error type
        const statusCode = result.error?.includes('Authentication') || result.error?.includes('credentials') ? 401 :
                          result.error?.includes('Invalid') ? 400 : 500;

        res.status(statusCode).json(result);
      }
    } catch (error: any) {
      console.error('[API /api/wordpress/publish] Unexpected error:', error);
      res.status(500).json({
        success: false,
        error: 'Server error while publishing to WordPress'
      });
    }
  });

  // Register releases download route
  app.use(releasesRouter);

  const httpServer = createServer(app);
  return httpServer;
}
AFTER YOU FINISH ALL FILE EDITS:

Run: cd client && npm run build

Report whether it passes or fails and include any errors if it fails.

Do NOT run any git commands.